//https://blog.csdn.net/Waves___/article/details/105295060#1.2%E3%80%81Read%20View%20%E7%BB%93%E6%9E%84
1.mvcc 多版本控制 实现依赖于 隐藏字段、Read View、Undo log
    1.1 只能在 RC 或者 RR 实现
    1.2 只有在写写才会进行行锁控制
  2.read view 主要是用来做可见性判断的, 里面保存了“对本事务不可见的其他活跃事务”。
    2.1 read view 也称为快照  只有在快照读下也就是普通的select语句（不包括 for update等）
        在RC下 只有在执行第一条select时会进行read view
        在RC下 每执行select语句都会更新当前read view
    2.2 read view内有四个参数 主要依靠前三个作为mvcc判断依据
     2.2.1  low_limit_id 目前出现的最大的事务id+1
     2.2.2  up_limit_id 目前活跃的事务中最小id 或者是说trx_ids中最小id（不包括自己）
     2.2.3  trx_ids 创建read view时活跃的未提交的事务id集合
     2.2.4  creator_trx_id 当前创建的事务id
  3.隐藏参数
    3.1 每一行数据都有三个隐藏列字段
    3.2 DB_TRX_ID(6字节) 表示最近一次的操作事务id 删除也认为是一种修改
    3.3 DB_ROLL_PTR(7字节) 表示当前数据行的回滚指针，指向undolog中的回滚数据
    3.4 DB_ROW_ID(6字节) 随着新行插入而单调递增的行ID。如果没有主键或者唯一索引，那么会把这个字段作为聚簇索引
    3.5 undolog 存储老版本数据 每当事务要读取数据时，如果当前数据不可见，则可以顺着undolog向上找，直到找到可见的老数据
      3.5.1 一种是insert存储 当事务结束时，只有在事务回滚时需要，事务提交后直接删除即可
      3.5.2 另一种update存储 当然删除也属于update一种，只有当快照里没有这个需要的时候就可以删除了
      3.5.3  Purge线程 专门来做undolog删除
      3.5.4 每次修改数据时，需要提交，只要修改了就会把新数据覆盖，并把老数据放入undolog中
  4.可见性比较算法
    4.1 概念：根据三个指标来判断当前事务是否可以查看行信息
      4.1.1 当前行的事务id（记录在行上的） 相当于隐藏参数中的 DB_TRX_ID，暂时叫trx_id
      4.1.2 read view中low_limit_id
      4.1.3 read view中up_limit_id
     4.2 如果进行判断
       4.2.1 如果trx_id < up_limit_id ,认为当前行数据的最新修改事务提交在当前快照之前，所以转向4.2.5
       4.2.2 如果trx_id > low_limit_id, 认为当前行数据的最新修改事务提交在快照之后，那么当前行数据对现在事务不可见，转向4.2.4
       4.2.3 如果 up_limit_id <= trx_id < low_limit_id 认为当前行数据的最新修改事务在快照时处于活跃状态或已提交状态，需要进行在read view 中trx_ids(二分查找)
         4.2.3.1 如果找到了，说明最新修改数据行的事务处于活跃状态，并在快照之前就对数据进行了修改并未提交 或者 在快照之后最新修改数据行修改了数据，不管哪一个都对当前事务不可见，转向4.2.4
         4.2.3.2 如果没找到，说明最新修改数据行事务已经提交了，说明最新修改改数据行的事务在当前事务快照之前就提交了，所以转向4.2.5
       4.2.4 从数据行中找到指向undolog的指针，取到旧的数据行，再转向4.2 使用旧数据进行新一轮的判断
       4.2.5 数据行对当前事务可见，返回查询值
  5.为什么RC 和RR 在可重复的读上会不一致？就是因为在快照读取的时候时机不同导致的。